% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flash_add_greedy.R
\name{flash.add.greedy}
\alias{flash.add.greedy}
\title{Greedily add factors to a flash object}
\usage{
flash.add.greedy(
  flash,
  Kmax = 1,
  ebnm.fn = ebnm::ebnm_point_normal,
  init.fn = init.fn.default,
  extrapolate = FALSE,
  warmstart = FALSE,
  conv.crit.fn = conv.crit.elbo,
  tol = set.default.tol(flash),
  maxiter = 500,
  verbose = NULL
)
}
\arguments{
\item{flash}{A \code{flash} or \code{flash.fit} object to which factors are
to be added.}

\item{Kmax}{The maximum number of factors to be added. This will not
necessarily be the total number of factors added by
\code{flash.add.greedy}, since factors are only added as long as they
increase the ELBO.}

\item{ebnm.fn}{The function or functions used to solve the empirical Bayes
  normal means (EBNM) subproblems. Most importantly, these functions specify
  the families of distributions \eqn{G_\ell^{(k)}} and \eqn{G_f^{(k)}} to which the
  priors on loadings and factors \eqn{g_\ell^{(k)}} and \eqn{g_f^{(k)}} are
  assumed to belong. If the same function is to be used for both loadings
  \eqn{L} and factors \eqn{F}, then \code{ebnm.fn} can be a single function.
  If one function is to be used for loadings and a second for factors,
  then \code{ebnm.fn} should be a list of length two, with the first
  element giving the function for loadings and the second the function
  for factors. If different functions are to be used for different values of
  \eqn{k}, then factor/loadings pairs must be added successively using
  multiple calls to either \code{\link{flash.add.greedy}} or
  \code{\link{flash.init.factors}}.

  Any EBNM function provided by package \code{\link[ebnm]{ebnm}} can be
  used as input. Non-default arguments to parameters can be supplied using
  the helper function \code{\link{as.ebnm.fn}}. Custom EBNM functions can
  also be used: for details, see \code{\link{as.ebnm.fn}}.}

\item{init.fn}{The function used to initialize factor/loadings pairs. Functions
\code{\link{init.fn.default}}, \code{\link{init.fn.softImpute}}, and
\code{\link{init.fn.irlba}} have been supplied
(\code{\link{init.fn.softImpute}} can yield better results than the
default initialization function when there is missing data). Custom
initialization functions may also be used. It is especially important to
use an appropriate initialization function when factors or loadings must be
constrained in some fashion --- otherwise, the greedy algorithm can stop
adding factor/loadings pairs too early. Custom initialization functions
should accept a single
parameter referring to a \code{\link{flash.fit}} object and should output
a list consisting of two vectors, which will be used as initial values for
the new loadings \eqn{\ell_k} and the new factor \eqn{f_k}. Typically,
a custom initialization function will extract the matrix of residuals from
the \code{flash.fit} object using the method \code{residuals.flash.fit} and
then return a (possibly constrained) rank-one approximation to the matrix
of residuals. See \strong{Examples} below.}

\item{extrapolate}{Whether to use an extrapolation technique
inspired by Ang and Gillis (2019) to accelerate the fitting process.
Control parameters are handled via global options and can be set by
calling \code{options("extrapolate.control") <- control.param}.}

\item{warmstart}{Whether to use "warmstarts" when solving the EBNM
subproblems by initializing solutions at the previous value of the fitted
prior \eqn{\hat{g}}. An important side effect of warmstarts for
\code{ashr}-like prior families is to fix the grid at its initial setting.
Fixing the grid can lead to poor fits if there
are large changes in the scale of the estimated prior over the
course of the fitting process. However, allowing the grid to
vary can occasionally result in decreases in ELBO.}

\item{conv.crit.fn}{The function used to calculate the optimization objective.
Fitting terminates (i.e., the fit is considered to have "converged") when
this objective drops below the value specified by parameter \code{tol}.
Options include \code{\link{conv.crit.elbo}} (the default),
\code{\link{conv.crit.loadings}}, and \code{\link{conv.crit.factors}}.
Custom functions may also be used. They should accept three parameters,
\code{new}, \code{old}, and \code{k}, where \code{new} refers to the
\code{\link{flash.fit}} object from the current iteration, \code{old}
refers to the \code{\link{flash.fit}} object from the previous iteration,
and \code{k} identifies the factor/loadings pair that is currently
being updated during sequential backfits (that is, in calls to function
\code{\link{flash.backfit}} where \code{extrapolate = FALSE}).}

\item{tol}{The convergence tolerance (see parameter \code{conv.crit.fn}
above).}

\item{maxiter}{The maximum number of iterations when optimizing a greedily
added factor.}

\item{verbose}{When and how to display progress updates. Set to
\code{0} for none, \code{1} for updates after a factor is added or a
backfit is completed, \code{2} for additional notifications about the
variational lower bound, and \code{3} for updates after every iteration.
It is also possible to output a single tab-delimited table of values
using function \code{\link{flash.set.verbose}} with \code{verbose = -1}.}
}
\value{
A \code{\link{flash}} object.
}
\description{
Adds factor/loadings pairs to a flash object in a "greedy" manner. Up to
  \code{Kmax} pairs are added one at a time. At each step, \code{flash.add.greedy}
  attempts to find an optimal additional (rank-one) factor given all
  previously added factors. The additional factor is retained if it
  increases the variational lower bound (ELBO); otherwise, fitting terminates.
}
\examples{
# Increase the maximum number of iterations in the default initialization
#   method.
fl <- flash.init(gtex) \%>\%
  flash.add.greedy(init.fn = function(f) init.fn.default(f, maxiter = 500))

# Fit a semi-nonnegative matrix factorization.
snmf.fl <- flash.init(gtex) \%>\%
  flash.add.greedy(
    ebnm.fn = c(ebnm::ebnm_unimodal_nonnegative, ebnm::ebnm_point_normal),
    init.fn = function(f) init.fn.default(f, dim.signs = c(1, 0))
  )

# Use a custom initialization function that wraps function nnmf from
#   package NNLM.
nnmf.init.fn <- function(f) {
  nnmf.res <- NNLM::nnmf(resid(f), verbose = FALSE)
  return(list(as.vector(nnmf.res$W), as.vector(nnmf.res$H)))
}
fl.nnmf <- flash.init(gtex) \%>\%
  flash.add.greedy(ebnm.fn = ebnm::ebnm_unimodal_nonnegative,
                   init.fn = nnmf.init.fn)

}
\seealso{
\code{\link{init.fn.default}}, \code{\link{init.fn.softImpute}},
  \code{\link{init.fn.irlba}}
}
